C data structure library: table
===============================

This document specifies the table library which belongs to C data structure
library. The basic structure is from David Hanson's book,
[C Interfaces and Implementations](https://sites.google.com/site/cinterfacesimplementations/).
I modified the original implementation to make it more appropriate for my other
projects and to enhance its readability.

The book explains its design and implementation in a very comprehensive way.
Not to mention the copyright issues, the internals of the library is not to be
explained here. Explanations for APIs, however, are given to aid the use of the
library.


## 1. Introduction

The table library implements
[tables](https://en.wikipedia.org/wiki/Associative_array) that are similar to
arrays except that nothing is imposed on the type of indices; it is also known
as a _dictionary_, _associative array_ or _map_ in some languages. A table
stores a key and its associated value, and its user is free to put new
key-value pairs, to retrieve a value from a key, to replace a value with a new
one, and to get rid of key-value pairs from a table. The storage used to
maintain a table itself is managed by the library, but any storage allocated
for data stored in tables should be managed by a user program.

This library reserves identifiers starting with `table_` and `TABLE_`, and
imports the assertion library (which requires the exception library) and the
memory library.


### 1.1. How to use the library

Similarly for other data structure libraries, use of the table library follows
this sequence: create, use and destroy. Except for functions to inspect tables,
all other functions do one of them in various ways.

`table_new()` that creates an empty table takes three unusual arguments. The
first one is a hint for the expected length of the table it will create, and
the other two are to specify user-defined functions that perform creation and
comparison of hash values used to represent keys. Some important conditions
that those functions have to satisfy are described in `table_new()`.

Using a table starts with creating one using `table_new()`. It is important to
give `table_new()` three arguments properly. If keys to a table are generated
by the hash library, the second and third arguments can be granted null
pointers, which lets internal functions used for the table. `table_new()`
allocates a storage necessary for a table and if no allocation is possible, an
exception is raised instead of returning a failure indicator like a null
pointer.

Once a table created, a key-value pair can be added to and removed from a table
using `table_put()` and `table_remove()`. Adding a pair to a table also entails
memory allocation, and thus an exception may be raised. `table_get()` takes a
key and returns its associated value if any, and `table_length()` gives the
number of key-value pairs in a table.

There are two ways to apply some operations on every pair in a table;
`table_map()` takes a user-defined function and calls it for each of key-value
pairs, and `table_toarray()` converts a table into a dynamic array; the array
converted from a table has keys in elements with even indices and values in
those with odd indices. Storage for the generated array is allocated by the
library (thus, an exception is possible again), but a user program is
responsible for releasing the storage when the array is no longer necessary.

`table_free()` takes a table and releases the storage used to maintain it. Note
that any storage allocated by a user program to contain or represent keys and
values is not deallocated by the library.


### 1.2. Boilerplate code

As an example, the following code creates a table (whose expected length is set
to 20 and keys are generated by the hash library), and uses it to compute the
frequencies of different characters in the input. To explain details, it first
inspects if the table already has an input character and its frequency in it.
If found, the frequency is simply increased. Otherwise, storage to contain the
frequency is allocated and put into the table after set properly. (This is
intended to just show an example for using a table; an ordinary array is enough
to print the frequencies of different characters that appear in the user
input.)

    int c;
    char b;
    int *pfrq;
    table_t *mytab;
    const char *key;
    void **pa, **pb;

    mytab = table_new(20, NULL, NULL);

    while ((c = getchar()) != EOF) {
        b = c;
        key = hash_new(&b, 1);
        if ((pfrq = table_get(mytab, key))) == NULL) {
            MEM_NEW(pfrq);
            *pfrq = 0;
        }
        (*pfrq)++;
        table_put(mytab, key, pfrq);
    }

    pa = table_toarray(mytab, NULL);
    for (pb = pa; *pb; pb += 2) {
        printf("%c: %d\n", *(char *)pb[0], *(int *)pb[1]);
        MEM_FREE(pb[1]);
    }
    MEM_FREE(pa);

    hash_reset();
    table_free(&mytab);

where `hash_new()` and `hash_reset()` come from the hash library, and
`MEM_NEW()` and `MEM_FREE()` from the memory library.

Things to note include:
- storages for keys and values to be stored into a table should be prepared by
  a user program, not the library, thus releasing them properly is up to the
  user program (`MEM_FREE()` in the `for` loop above and `hash_reset()` release
  them);
- because a table has pointers to objects for the frequencies, not their
  values, increasing values in the objects effectively updates the table; and
- an array generated by `table_toarray()` has to be deallocated by a user code.


## 2. APIs

### 2.1. Types

#### `table_t`

`table_t` represents a table.


### 2.2. Creating and Destroying tables

#### `table_t *table_new(int, int cmp(), unsigned hash())`

`table_new()` creates a new table. It takes some information on a table it will
create:
- `hint`: an estimated size of a table;
- `cmp`: a user-provided function of type `int (const void *, const void *)` to
  compare members; and
- `hash`: a user-provided function of type `unsigned (const void *)` to
  generatefor generating a hash value from a key

`table_new()` determines the size of the internal hash table kept in a table
based on `hint`. It never restricts the number of entries one can put into a
table, but a better estimate probably gives better performance.

A function given to `cmp` should be defined to take two arguments and to return
a value less than, equal to or greater than zero to indicate that the first
argument is less than, equal to or greater than the second argument,
respectively.

A function given to `hash` takes a key and returns a hash value that is to be
used as an index for the internal hash table in a table. If the `cmp` function
returns zero (which means they are equal) for two keys, the `hash` function
must generate the same value for them.

If a null pointer is given for `cmp` or `hash`, the default comparison or
hashing function is used; see `defhashCmp()` and `defhashGen()`, in which case
keys are assumed to be hash strings generated by the hash library. An example
follows:

    table_t *mytable = table_new(hint, NULL, NULL);
    int *pi, val1, val2;
    /* ... */
    table_put(hash_string("key1"), &val1);
    table_put(hash_string("key2"), &val2);
    pi = table_get(hash_string(key1));
    assert(pi == &val1);

##### May raise

`mem_exceptfail` (see the memory library from `cbl`).

##### Takes

| Name  | In/out | Meaning                               |
|:-----:|:------:|:--------------------------------------|
| hint  | in     | hint for the size of table            |
| cmp   | in     | user-defined comparison function      |
| hash  | in     | user-defined hash generation function |

##### Returns

A new table created.


#### `void table_free(table_t **ptable)`

`table_free()` destroys a table by deallocating the storage for it and set a
given pointer to the null pointer. As always, `table_free()` does not
deallocate storages for values in the table, which must be done by a user.

##### May raise

`assert_exceptfail` (see the assertion library from `cbl`).

##### Takes

| Name   | In/out | Meaning                     |
|:------:|:------:|:----------------------------|
| ptable | in/out | pointer to table to destroy |

##### Returns

Nothing.


### 2.3. Handling data in a table

#### `size_t table_length(const table_t *table)`

`table_length()` returns the length of a table which is the number of key-value
pairs in a table.

##### May raise

`assert_exceptfail` (see the assertion library).

##### Takes

| Name  | In/out | Meaning                             |
|:-----:|:------:|:------------------------------------|
| table | in     | table whose length will be returned |

##### Returns

The length of a table.


#### `void *table_put(table_t *table, const void *key, void *value)`

`table_put()` replaces an existing value for a key with a new one and returns
the previous value. If there is no existing one, the value is saved for the key
and returns a null pointer.

Note that both a key and a value are pointers. If values are, say, integers in
an application, objects to contain them are necessary to put them into a table.

##### May raise

`assert_exceptfail` (see the assertion library) and `mem_exceptfail` (see the
memory library).

##### Takes

| Name  | In/out | Meaning                             |
|:-----:|:------:|:------------------------------------|
| table | in/out | table to which value will be stored |
| key   | in     | key to store into a table           |
| value | in     | value to store into a table         |

##### Returns

The previous value for the key or null pointer.

_If the stored value was a null pointer, an ambiguous situation may occur._


#### `void *table_get(const table_t *table, const void *key)`

`table_get()` returns a value associated with a key.

##### May raise

`assert_exceptfail` (see the assertion library).

##### Takes

| Name  | In/out | Meaning                                            |
|:-----:|:------:|:---------------------------------------------------|
| table | in     | table from which a key-value pair will be searched |
| key   | in     | key to find from table                             |

##### Returns

The value for a given key or null pointer.

_If the stored value was a null pointer, an ambiguous situation may occur._


#### `void *table_remove(table_t *table, const void *key)`

`table_remove()` gets rid of a key-value pair for a key from a table. Note that
`table_remove()` does not deallocate any storage for the pair to remove, which
must be done by an user.

##### May raise

`assert_exceptfail` (see the assertion library)

##### Takes

| Name  | In/out | Meaning                                           |
|:-----:|:------:|:--------------------------------------------------|
| table | in     | table from which a key-value pair will be removed |
| key   | in     | key to remove                                     |

##### Returns

The value for a given key or null pointer.

_If the stored value is a null pointer, an ambiguous situation may occur._


### 2.4. Handling tables

#### `void table_map(table_t *table, void apply(const void *, void **, void *), void *cl)`

For each key-value pair in a table, `table_map()` calls a user-provided
callback function; it is useful when doing some common task for each key-value
pair. The callback function has a type of
`void (const void *, void **, void *)`, and a key, a pointer to a value and the
passing-by argument `cl` are passed to it.

The pointer given in `cl` is passed to the third parameter of a user callback
function, so can be used as a communication channel between the caller of
`table_map()` and the callback. Because the callback has the address of a value
through the second parameter, it is free to change its content.

_The order in which a user-provided function is called for each key-value pair
is unspecified._

##### May raise

`assert_exceptfail` (see the assertion library).

##### Takes

| Name  | In/out | Meaning                                   |
|:-----:|:------:|:------------------------------------------|
| table | in/out | table with which `apply()` will be called |
| apply | in     | user-provided function (callback)         |
| cl    | in     | passing-by argument to `apply()`          |

##### Returns

Nothing.


#### `void **table_toarray(const table_t *table, void *end)`

`table_toarray()` converts key-value pairs stored in a table to an array. The
last element of the constructed array is assigned by `end`, which is a null
pointer in most cases. Do not forget to deallocate the array when it is
unnecessary.

The resulting array is consisted of key-value pairs: its elements with even
indices have keys and those with odd indices have corresponding values. For
example, the second element of a resulting array has a value corresponding to a
key stored in the first element. Note that the end-marker given as `end` has no
corresponding value element.

_The size of an array generated from an empty table cannot be zero, because
there is always an end-mark value._

_As in `table_map()`, the order in which an array is created for each key-value
pair is unspecified._

##### May raise

`assert_exceptfail` (see the assertion library) and `mem_exceptfail` (see the
memory library).

##### Takes

| Name  | In/out | Meaning                                          |
|:-----:|:------:|:-------------------------------------------------|
| table | in     | table from which an array will be generated      |
| end   | in     | end-mark to save in the last element of an array |

##### Returns

An array generated from a table.


## 3. Future directions

### 3.1. Retaining sequence

The table library offers two functions that scan every key-value pair
maintained in tables. These functions visit key-value pairs in order that is
dependent on the internal structure of the table, which might force a user to
sort them properly if certain sequence is desired. It would be thus helpful to
have those functions to retain sequence in which key-value pairs are stored
into tables.


## 4. Contact me

Visit [`code.woong.org`](https://code.woong.org) to get the latest version of
this library. Any comments about the library are welcomed. If you have a
proposal or question on the library just email me, and I will reply as soon as
possible.


## 5. Copyright

For the copyright issues, see `LICENSE.md`.
