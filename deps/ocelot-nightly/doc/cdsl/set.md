C data structure library: set
=============================

This document specifies the set library which belongs to C data structure
library. The basic structure is from David Hanson's book,
[C Interfaces and Implementations](https://sites.google.com/site/cinterfacesimplementations/).
I modified the original implementation to make it more appropriate for my other
projects and to enhance its readability.

The book explains its design and implementation in a very comprehensive way.
Not to mention the copyright issues, the internals of the library is not to be
explained here. Explanations for APIs, however, are given to aid the use of the
library.


## 1. Introduction

The set library implements sets whose concept does not differ from that in
mathematics. You can also regard it as a table where values do not have
associated keys and act as keys by themselves. Because a value in a set is also
a key, two instances of the same value refer to the same element in the set.
The storage used to maintain a set itself is managed by the library, but any
storage allocated for data stored in sets should be managed by a user program.

This library reserves identifiers starting with `set_` and `SET_`, and imports
the assertion library (which requires the exception library) and the memory
library.


### 1.1. How to use the library

Similarly for other data structure libraries, use of the set library follows
this sequence: create, use and destroy. Except for functions to inspect sets,
all other functions do one of them in various ways.

`set_new()` that creates an empty set takes three unusual arguments. The first
one is a hint for the expected length of the set it will create, and the other
two are to specify user-defined functions that perform creation and comparison
of hash values to represent members. Some important conditions that those
functions have to satisfy are described in `set_new()`.

In general, a null pointer given to an argument expecting a set is considered
an error which results in an assertion failure, but the functions for set
operations (`set_union()`, `set_inter()`, `set_minus()` and `set_diff()`) take
a null pointer as valid and treat it as representing an empty set. Also note
that they always produce a distinct set; none of them alters the original set.

Using a set starts with creating one using `set_new()`. It is important to
give `set_new()` three arguments properly. If members to a set are generated by
the hash library, the second and third arguments can be granted null pointers,
which lets internal functions used for the set. There are other ways to create
sets from an existing set with `set_union()`, `set_inter()`, `set_minus()` and
`set_diff()` (getting a union, intersection, difference, symmetric difference
of sets, respectively); This library does not define the concept of a universe,
thus no support for a complement. All set creation functions allocate storage
for a set and if no allocation is possible, an exception is raised instead of
returning a failure indicator like a null pointer.

Once a set created, a member can be added to or removed from a set using
`set_put()` or `set_remove()`. Adding a member to a set also entails memory
allocation, and thus an exception can be raised. `set_member()` inspects if a
set contains a specific member, and `set_length()` gives the number of members
in a set.

There are two ways to apply some operations on every member in a set;
`set_map()` takes a user-defined function and calls it for each of members, and
`set_toarray()` converts a set into a dynamic arrays. Storage for the generated
array is allocated by the library (thus, an exception is possible again), but a
user program is responsible for releasing the storage when the array is no
longer necessary.

`set_free()` takes a set and releases the storage used to maintain it. Note
that any storage allocated by a user program to contain or represent members is
not deallocated by the library.


### 1.2. Boilerplate code

As an example, the following code creates two sets (whose expected length is
set to 20 and members are generated by the hash library) and those sets have
input characters as members by turns. It then obtains from them a union and an
intersection and enumerates members in the resulting sets.

    int c;
    char b;
    unsigned i = 0;
    void **pa, **pb;
    set_t *myset1, *myset2, *u, *t;

    myset1 = set_new(20, NULL, NULL);
    myset2 = set_new(20, NULL, NULL);

    while ((c = getchar()) != EOF) {
        b = c;
        set_put((i++ % 2 == 0)? myset1: myset2, hash_new(&b, 1));
    }

    u = set_union(myset1, myset2);
    t = set_inter(myset1, myset2);

    set_free(&myset1);
    set_free(&myset2);

    pa = set_toarray(u, NULL);
    printf("union: ");
    for (pb = pa; *pb; pb++)
        printf("%c", *(char *)*pb);
    MEM_FREE(pa);

    pa = set_toarray(t, NULL);
    printf("\nintersection: ");
      for (pb = pa; *pb; pb++)
        printf("%c", *(char *)*pb);
    MEM_FREE(pa);

    hash_reset();
    set_free(&u);
    set_free(&t);

where `hash_new()` and `hash_reset()` come from the hash library, and
`MEM_NEW()` and `MEM_FREE()` from the memory library.

Things to note include:
- it is not a character itself but a hash value for it that is put into a
  set;
- because all set operations produce a distinct set, it is possible to destroy
  `myset1` and `myset2` after their union and intersection have been obtained;
- arrays generated by `set_toarray()` have to be deallocated by a user code;
  and
- storages for members in a set should be released by a user code. `set_free()`
  does not care about them (members are hash values given by `hash_new() in
  this example, thus `hash_reset() is used to release storages for them.)


## 2. APIs

### 2.1. Types

#### `set_t`

`set_t` represents a set.


### 2.2. Creating and destroying sets

#### `set_t *set_new (int hint, int cmp(), unsigned hash())`

`set_new()` creates a new set. It takes some information on a set it will
create:
- `hint`: an estimated size of a set;
- `cmp`: a user-provided function of type `int (const void *, const void *)`
  to compare members; and
- `hash`: a user-provided function of type `unsigned (const void *)` to
  generate a hash value for a member

`set_new()` determines the size of the internal hash table kept in a set based
on `hint`. It never restricts the number of members one can put into a set, but
a better estimate probably gives better performance.

A function given to `cmp` should be defined to take two arguments and to return
a value less than, equal to or greater than zero to indicate that the first
argument is less than, equal to or greater than the second argument,
respectively.

A function given to `hash` takes a member and returns a hash value that is to
be used as an index for internal hash table in a set. If the `cmp` function
returns zero (which means they are equal) for some two members, the `hash`
function must generate the same value for them.

If a null pointer is given for `cmp` or `hash`, the default comparison or
hashing function is used; see `defhashCmp()` and `defhashGen()`, in which case
members are assumed to be hash strings generated by the hash library. An
example follows:

    set_t *myset = set_new(hint, NULL, NULL);
    /* ... */
    set_put(hash_string("member1"));
    set_put(hash_string("member2"));
    assert(set_member(hash_string("member1")));

##### May raise

`mem_exceptfail` (see the memory library from `cbl`).

##### Takes

| Name  | In/out | Meaning                               |
|:-----:|:------:|:--------------------------------------|
| hint  | in     | hint for the size of hash table       |
| cmp   | in     | user-defined comparison function      |
| hash  | in     | user-defined hash generation function |

##### Returns

A new set created.


#### `void set_free(set_t **pset)`

`set_free()` destroys a set by deallocating the storage for it and set a given
pointer to a null pointer. As always, `set_free()` does not deallocate any
storage for members in the set, which must be done by a user.

##### May raise

`assert_exceptfail` (see the assertion library from `cbl`).

##### Takes

| Name  | In/out | Meaning                   |
|:-----:|:------:|:--------------------------|
| pset  | in/out | pointer to set to destroy |

##### Returns

Nothing.


### 2.3. Handling elements in a set

#### `size_t set_length(set_t *set)`

`set_length()` returns the length of a set which is the number of members in a
set.

##### May raise

`assert_exceptfail` (see the assertion library).

##### Takes

| Name  | In/out | Meaning                           |
|:-----:|:------:|:----------------------------------|
| set   | in     | set whose length will be returned |

##### Returns

The length of set.


#### `int set_member(set_t *set, const void *member)`

`set_member()` inspects a set to see if it contains a member.

##### May raise

`assert_exceptfail` (see the assertion library).

##### Takes

| Name   | In/out | Meaning                 |
|:------:|:------:|:------------------------|
| set    | in     | set to inspect          |
| member | in     | member to find in a set |

##### Returns

| Value | Meaning          |
|:-----:|:-----------------|
| `0`   | member not found |
| `1`   | member found     |


#### `void set_put(set_t *set, const void *member)`

`set_put()` inserts a member to a set.

If it fails to find a member matched to a given member, the member will be
inserted into a set after proper storage allocation. If it finds a matched one,
it replaces an existing member with the new one. Because they may have
different representations even if they compare equal by a user-defined
comparison function, replacing the old one makes sense.

Note that a member is a pointer. If members are, say, integers in an
application, objects to contain them are necessary to put them into a set.

##### May raise

`assert_exceptfail` (see the assertion library) and `mem_exceptfail` (see the
memory library).

##### Takes

| Name   | In/out | Meaning                              |
|:------:|:------:|:-------------------------------------|
| set    | in/out | set to which member will be inserted |
| member | in     | member to insert                     |

##### Returns

Nothing.


#### `void *set_remove(set_t *set, const void *member)`

`set_remove()` gets rid of a member from a set. Note that `set_remove()` does
not deallocate any storage for the member to remove, which must be done by a
user.

##### May raise

`assert_exceptfail` (see the assertion library).

##### Takes

| Name   | In/out | Meaning                               |
|:------:|:------:|:--------------------------------------|
| set    | in/out | set from which member will be removed |
| member | in     | member to remove                      |

##### Returns

The previous member or null pointer.

_If the stored member is a null pointer, an ambiguous situation may occur._


### 2.4. Handling sets

#### `void set_map(set_t *set, void apply(), void *cl)`

For each member in a set, `set_map()` calls a user-provided callback function;
it is useful when doing some common task for each member. The callback function
has a type of `void (const void *, void *)`, and a member and the passing-by
argument `cl` are passed to it.

The pointer given in `cl` is passed to the third parameter of a user callback
function, so can be used as a communication channel between the caller of
`set_map()` and the callback. Differently from `table_map()` (from the table
library), `set_map()` gives a member to `apply()` rather than a pointer to it
This is very natural considering that a member plays a role of a hashing key
for a set as a key does for a table. Also note that `apply()` is not able to
modify a member itself but can touch a value pointed by the member.

_The order in which a user-provided function is called for each member is
unspecified; a set is an unordered collection of members, so this is not a
limiting factor, however._

##### May raise

`assert_exceptfail` (see the assertion library).

##### Takes

| Name  | In/out | Meaning                                 |
|:-----:|:------:|:----------------------------------------|
| set   | in/out | set with which `apply()` will be called |
| apply | in     | user-provided function (callback)       |
| cl    | in     | passing-by argument to `apply()`        |

##### Returns

Nothing.


#### `void **set_toarray(set_t *set, void *end)`

`set_toarray()` converts members stored in a set to an array. The last element
of the constructed array is assigned by `end`, which is a null pointer in most
cases. Do not forget deallocate the array when it is unnecessary.

The size of an array generated from an empty set cannot be zero, because there
is always an end-mark value.

_As for `set_map()`, the order in which an array is created for each member is
unspecified._

##### May raise

`assert_exceptfail` (see the assertion library) and `mem_exceptfail` (from the
memory library).

##### Takes

| Name  | In/out | Meaning                                       |
|:-----:|:------:|:----------------------------------------------|
| set   | in     | set for which array will be generated         |
| end   | in     | end-mark to save in the last element of array |

##### Returns

An array generated from a set.


### 2.5. Set operations

For every set operation, the result constitutes a distinct set from the operand
sets, which means the set operations always allocate storage for their results
even when one of the operands is empty.

One of the operands may be a null pointer, in which case it is considered an
empty set.

Note that the interface of the set library does not assume the concept of a
universe. Thus, a set operation like the complement is not defined and not
implemented.

#### `set_t *set_union(set_t *s, set_t *t)`

`set_union()` creates a union set of two sets and returns it.

_To create a union of two sets, they have to share the same comparison and
hashing functions._

##### May raise

`assert_exceptfail` (see the assertion library) and `mem_exceptfail` (from the
memory library).

##### Takes

| Name | In/out | Meaning                        |
|:----:|:------:|:-------------------------------|
| s    | in     | operand of set union operation |
| t    | in     | operand of set union operation |

##### Returns

A union of two sets.


#### `set_t *set_inter(set_t *s, set_t *t)`

`set_inter()` returns an intersection of two sets, that is a set with only
members that both have in common.

##### May raise

`assert_exceptfail` (see the assertion library) and `mem_exceptfail` (from the
memory library).

##### Takes

| Name | In/out | Meaning                               |
|:----:|:------:|:--------------------------------------|
| s    | in     | operand of set intersection operation |
| t    | in     | operand of set intersection operation |

##### Returns

An intersection of two sets.


#### `set_t *set_minus(set_t *s, set_t *t)`

`set_minus()` returns a difference of two sets, that is a set with members that
`t` has but `s` does not.

##### May raise

`assert_exceptfail` (see the assertion library) and `mem_exceptfail` (from the
memory library).

##### Takes

| Name | In/out | Meaning                               |
|:----:|:------:|:--------------------------------------|
| s    | in     | operand of set difference operation |
| t    | in     | operand of set difference operation |

##### Returns

A difference of two sets, `s` - `t`.


#### `set_t *set_diff(set_t *s, set_t *t)`

`set_diff()` returns a symmetric difference of two sets, that is a set with
members only one of two operand sets has.

A symmetric difference set is identical to the union set of (`s` - `t`) and
(`t` - `s`).

##### May raise

`assert_exceptfail` (see the assertion library) and `mem_exceptfail` (from the
memory library).

##### Takes

| Name | In/out | Meaning                               |
|:----:|:------:|:--------------------------------------|
| s    | in     | operand of set difference operation |
| t    | in     | operand of set difference operation |

##### Returns

A symmetric difference of two sets.


## 3. Future directions

### 3.1. Storing hash numbers

Modifying the data structure for sets to have hash numbers explicitly makes it
possible for a user-provided hashing function to be called only once for each
member in sets and for a user-provided comparison function to be called only
when the hash numbers differ, which leads to the performance improvement.


### 3.2. Improvement on set operations

Set operations like `set_union()`, `set_inter()`, `set_minus()` and
`set_diff()` can be improved when two sets on which the operations are
performed have the same number of buckets by applying the operations to each
pair of corresponding buckets.


## 4. Contact me

Visit [`code.woong.org`](https://code.woong.org) to get the latest version of
this library. Any comments about the library are welcomed. If you have a
proposal or question on the library just email me, and I will reply as soon as
possible.


## 5. Copyright

For the copyright issues, see `LICENSE.md`.
